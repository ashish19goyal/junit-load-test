package junit.load.test;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.math3.stat.descriptive.rank.Percentile;

import java.io.IOException;
import java.lang.reflect.Method;
import java.util.*;

import static java.util.stream.Collectors.groupingBy;

/**
 * This class manages the results of load testing
 * When all tests are executed, it save the results in the form of csv and json files
 * @author Ashish Goyal
 */
class LoadTestReporter {

    private Map<String, TestResults> results = new HashMap<>();
    private FileHelper csvHelper;
    private FileHelper jsonHelper;
    private FileHelper htmlHelper;
    private long startTime;
    private long totalDuration;

    /**
     * Constructor accepts file helpers for csv, json and html reports
     * @param csvHelper
     * @param jsonHelper
     * @param htmlHelper
     */
    LoadTestReporter(FileHelper csvHelper, FileHelper jsonHelper, FileHelper htmlHelper) {
        this.csvHelper = csvHelper;
        this.jsonHelper = jsonHelper;
        this.htmlHelper = htmlHelper;
    }

    /**
     * This is executed for every iteration of a load test, if the iteration doesn't throw any exceptions
     * @param testObject Reference object to invoke the test method
     * @param testMethod Test Method that was invoked
     * @param startTime time at which the iteration was started
     */
    void markSuccess(Object testObject, Method testMethod, long startTime) {
        long timeTaken = System.currentTimeMillis() - startTime;
        TestResults result = getThreadSafeResultObject(testObject, testMethod);
        result.successCount.getAndIncrement();
        result.latencies.add(timeTaken);
    }

    /**
     * This is executed for every iteration of a load test, if any exceptions are thrown from it
     * @param testObject Reference object to invoke the test method
     * @param testMethod Test Method that was invoked
     * @param startTime time at which the iteration was started
     */
    void markError(Object testObject, Method testMethod, long startTime) {
        long timeTaken = System.currentTimeMillis() - startTime;
        TestResults result = getThreadSafeResultObject(testObject, testMethod);
        result.errorCount.getAndIncrement();
        result.latencies.add(timeTaken);
    }

    /**
     * After the execution of all iterations for a test,
     * this method helps in determining if the test should be considered successful
     * @param testObject Reference object to invoke the test method
     * @param testMethod Test Method that was invoked
     * @param errorThreshold Maximum allowed error rate to mark the execution as success
     * @return
     */
    boolean isSuccess(Object testObject, Method testMethod, float errorThreshold) {
        TestResults result = getThreadSafeResultObject(testObject, testMethod);
        if (errorThreshold == 0) {
            result.isSuccess = result.errorCount.get() <= 0;
            return result.isSuccess;
        }
        float errorRate = result.errorCount.get() / (result.successCount.get() + result.errorCount.get());
        result.isSuccess = errorRate <= errorThreshold;
        return result.isSuccess;
    }

    /**
     * After execution of all test suites, reports are generated by calling this method
     */
    void generateReport() {
        ResultsReport resultsReport = getResultsReport();
        generateCsvReport(resultsReport);
        generateJsonReport(resultsReport);
        generateHtmlReport();
        System.out.println("Load testing report is generated. Open this link in browser to access the report - http://localhost:63342/testing/testing.app/build/load-test/index.html ");
    }

    /**
     * This is executed before the start of test suites execution to record start time
     */
    void markStarted() {
        this.startTime = System.currentTimeMillis();
    }

    /**
     * This is executed after all test suites are executed to record total time of execution
     */
    void markDone() {
        this.totalDuration = System.currentTimeMillis() - startTime;
    }

    /**
     * Copies html file from resource to build folder
     * HTML contains JS to parse and load the json report in html format
     */
    private void generateHtmlReport() {
        htmlHelper.copy("load-test.html");
    }

    /**
     * Serializes the test results and saves it in json format
     * @param resultsReport Test results report
     */
    private void generateJsonReport(ResultsReport resultsReport) {
        jsonHelper.clear();
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
            jsonHelper.write(objectMapper.writeValueAsString(resultsReport));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Serializes the test results in csv format
     * @param resultsReport Test results report
     */
    private void generateCsvReport(ResultsReport resultsReport) {
        String heading = "test-suite,test-method,iterations,error-count,status,time-taken(average),time-taken(median),time-taken(p95),time-taken(p99)\n";
        try {
            csvHelper.clear();
            csvHelper.write(heading);
        } catch (IOException e) {
            e.printStackTrace();
        }

        for (TestResultsReport entry : resultsReport.tests) {
            String line = String.format("%s,%s,%d,%d,%s,%.2f,%.2f,%.2f,%.2f\n",
                    entry.testSuite,
                    entry.testMethod,
                    entry.iterations,
                    entry.errorCount,
                    entry.status,
                    entry.averageTimeTaken,
                    entry.medianTimeTaken,
                    entry.p95TimeTaken,
                    entry.p99TimeTaken);
            try {
                csvHelper.write(line);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Aggregates test results into a publishable format
     * @return Publishable test results
     */
    private ResultsReport getResultsReport() {
        ResultsReport result = new ResultsReport();
        List<TestResultsReport> testResultsReport = new ArrayList<>();
        List<SuiteResultsReport> suiteResultsReport = new ArrayList<>();

        // preparing results for each test
        for (Map.Entry<String, TestResults> entry : results.entrySet()) {
            TestResultsReport reportEntry = new TestResultsReport();
            reportEntry.testSuite = entry.getValue().testObject.getClass().getName();
            reportEntry.testMethod = entry.getValue().testMethod.getName();
            reportEntry.errorCount = entry.getValue().errorCount.get();
            reportEntry.iterations = entry.getValue().successCount.get() + entry.getValue().errorCount.get();
            reportEntry.latencies = entry.getValue().latencies;
            reportEntry.status = entry.getValue().isSuccess ? "pass" : "fail";
            double[] latencies = entry.getValue().latencies.stream().mapToDouble(Long::doubleValue).toArray();
            Percentile percentile = new Percentile();
            percentile.setData(latencies);
            reportEntry.averageTimeTaken = roundOff(Arrays.stream(latencies).average().getAsDouble());
            reportEntry.medianTimeTaken = roundOff(percentile.evaluate(50.00));
            reportEntry.p95TimeTaken = roundOff(percentile.evaluate(95.00));
            reportEntry.p99TimeTaken = roundOff(percentile.evaluate(99.00));

            testResultsReport.add(reportEntry);
        }

        result.tests = testResultsReport;

        // preparing results for each test suite
        Map<String, List<TestResults>> testResultsBySuite = results.values().stream()
            .collect(groupingBy(x-> x.testObject.getClass().getName()));
        for (Map.Entry<String, List<TestResults>> entry : testResultsBySuite.entrySet()) {
            SuiteResultsReport reportEntry = new SuiteResultsReport();
            reportEntry.testSuite = entry.getKey();

            for (TestResults testResult: entry.getValue()) {
                reportEntry.iterations += testResult.errorCount.get() + testResult.successCount.get();
                reportEntry.errorCount += testResult.errorCount.get();
                reportEntry.latencies.addAll(testResult.latencies);
                reportEntry.testCount++;
                if (testResult.isSuccess) {
                    reportEntry.testPassed++;
                }
            }
            double[] latencies = reportEntry.latencies.stream().mapToDouble(Long::doubleValue).toArray();
            Percentile percentile = new Percentile();
            percentile.setData(latencies);
            reportEntry.averageTimeTaken = roundOff(Arrays.stream(latencies).average().getAsDouble());
            reportEntry.medianTimeTaken = roundOff(percentile.evaluate(50.00));
            reportEntry.p95TimeTaken = roundOff(percentile.evaluate(95.00));
            reportEntry.p99TimeTaken = roundOff(percentile.evaluate(99.00));
            suiteResultsReport.add(reportEntry);
        }

        result.suites = suiteResultsReport;
        result.totalDuration = totalDuration;
        return result;
    }

    /**
     * Sets and Gets a {@link TestResults} object in an in-memory map
     * The returned TestResults object is updated after execution of every iteration of test method
     * @param testObject Reference object for invoking test method
     * @param testMethod Invoked test method
     * @return {@link TestResults}
     */
    private synchronized TestResults getThreadSafeResultObject(Object testObject, Method testMethod) {
        String key = testObject.getClass().getName() + "-" + testMethod.getName();
        if (!results.containsKey(key)) {
            results.put(key, new TestResults(testObject, testMethod));
        }
        return results.get(key);
    }

    /**
     * Round offs the provided number to two decimal places
     * Used for reporting
     * @param number
     * @return Rounded-off value
     */
    private double roundOff(double number) {
        return Math.round(number * 100.0) / 100.0;
    }
}
